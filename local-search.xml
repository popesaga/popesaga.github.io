<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构和算法：Bloom Filter</title>
    <link href="/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ABloom%20filter/"/>
    <url>/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ABloom%20filter/</url>
    
    <content type="html"><![CDATA[<p>如何高效判断元素 w 是否存在于集合 A 之中？首先想到的答案是，把集合 A 中的元素一个个放到哈希表中，然后在哈希表中查一下 w 即可。但如果 A 中元素数量巨大，甚至数据量远远超过机器内存空间，该如何解决问题呢？实现一个基于磁盘和内存的哈希索引当然可以解决这个问题。而另一种低成本的方式就是借助Bloom Filter（布隆过滤器）来实现。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Bloom Filter（布隆过滤器）是一种高效利用空间的概率数据结构，由 Burton Howard Bloom 于 1970 年提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。Bloom Filter 可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/bloomFilterWorkflow.png" alt="bloomFilterWorkflow"></p><p>以上图为例，具体的操作流程：假设集合里面有 3 个元素 {x, y, z}，哈希函数的个数为 3。</p><p>首先将位数组进行初始化，将里面每个位都设置位 0。对于集合里面的每一个元素，将元素依次通过 3 个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为 1。</p><p>查询 W 元素是否存在集合中的时候，同样的方法将 W 通过哈希映射到位数组上的 3 个点。如果 3 个点的其中有一个点不为 1，则可以判断该元素一定不存在集合中。反之，如果 3 个点都为 1，则该元素可能存在集合中。</p><p>注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为 4，5，6 这 3 个点。虽然这 3 个点都为 1，但是很明显这 3 个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是 1，这是误判率存在的原因。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Bloom Filter 基于位图的模式带来两个问题：</p><ul><li><p>误报（false positives）：</p><p>在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同 bit 位上，导致该位置 1，那么一个不存在的元素可能会被误报成存在。</p></li><li><p>漏报（false nagatives）：</p><p>如果删除了某个元素，导致该映射 bit 位被置 0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以 Bloom Filter 必须确保”definitely no”从而容忍“probably yes”，不允许元素的删除。</p><p>关于元素删除的问题，一个改良方案是对 Bloom Filter 引入计数（Counting Bloom filters），但这样一来，原来每个 bit 空间就要扩张成一个计数值，空间效率上又降低了。</p></li></ul><h3 id="在-HBase-中的应用"><a href="#在-HBase-中的应用" class="headerlink" title="在 HBase 中的应用"></a>在 HBase 中的应用</h3><p>Bloom Filter 只需占用极小的空间，便可给出“可能存在”和“肯定不存在”的存在性判断。因此 HBase 可以在 Get 操作时通过使用 Bloom Filter 来过滤大量无效数据块，从而节省大量磁盘 IO。</p><p>HBase 中用户可以对某些列设置不同类型的 Bloom Filter，共有三种类型：</p><ul><li>NONE：关闭 Bloom Filter 功能。</li><li>ROW：按照 rowkey 来计算 Bloom Filter 的二进制串并存储。Get 查询的时候，必须带 rowkey，所以用户可以在建表时默认把 Bloom Filter 设置为 ROW 类型。</li><li>ROWCOL：按照 rowkey + family + qualifier 这3个字段拼出 byte[] 来计算 Bloom Filter 值并存储。如果在查询的时候，Get 能指定rowkey、family、qualifier 这3个字段，则肯定可以通过 Bloom Filter 提升性能。但是如果在查询的时候，Get 中缺少 rowkey、family、qualifier 中任何一个字段，则无法通过 Bloom Filter 提升性能，因为计算 Bloom Filter 的 Key 不确定。</li></ul><p>一般意义上的 Scan 操作，HBase 都没法使用 Bloom Filter 来提升扫描数据性能。因为此时 Bloom Filter 的 Key 值不确定，所以没法计算出哈希值对比。但是，在某些特定场景下，Scan操作同样可以借助 Bloom Filter 提升性能。</p><p>对于 ROWCOL 类型的 Bloom Filter 来说，如果在 Scan 操作中明确指定需要扫某些列。那么在 Scan 过程中，碰到 KV 数据从一行换到新的一行时，是没法走 ROWCOL 类型 Bloom Filter 的，因为新一行的 key 值不确定；但是，如果在同一行数据内切换列时，则能通过 ROWCOL 类型 Bloom Filter 进行优化，因为 rowkey 确定，同时 column 也已知，也就是说，Bloom Filter 中的Key确定，所以可以通过ROWCOL 优化性能。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter英文维基</a></p><p><a href="https://crossoverjie.top/2018/11/26/guava/guava-bloom-filter/">如何判断一个元素在亿级数据中是否存在？</a></p><p><a href="https://book.douban.com/subject/34819650/">HBase原理与实践</a></p><p><a href="https://coolshell.cn/articles/17225.html">CUCKOO FILTER：设计与实现（一种 Bloom Filter 的替代方案）</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>Bloom filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法：LSM Tree</title>
    <link href="/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ALSM%20tree/"/>
    <url>/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ALSM%20tree/</url>
    
    <content type="html"><![CDATA[<p>LSM tree全称是 Log-structured merge-tree，是一种分层，有序，面向磁盘的数据结构。其核心原理是磁盘批量顺序写比随机写性能高出很多，可以通过围绕这一原理进行设计和优化，让写性能达到最优。相较于传统的B+树，它减少了磁盘随机读取的需求，从而在一定程度上改善了数据库的写能力，当然在一定程度上牺牲了数据库的读能力。LSM tree 也是当今流行的各种 NoSQL 或 NewSQL 数据库最基础的底层数据结构，广泛使用在包括 Hbase，Cassandra，Leveldb，RocksDB，TiDB 等项目中。</p><a id="more"></a><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>传统的 B+ 树的缺陷就是在访问节点时涉及到了大量的磁盘随机读写，因为你无法保证节点常驻内存，尤其是当 B+ 树管理的索引量很大的时候。这导致数据库读写性能急剧下降。</p><p> LSM tree 采取的做法就是通过引入多部件索引来减少磁盘随机读写的需求。在大量插入情况下我们周期性地选取两部分索引进行合并，并且把合并后的有序文件（或内存块）添加到磁盘尾部（或成为新文件），修改节点信息以保证索引树的正确和完整，并且周期性地回收失效索引。因此与其说 LSM tree 是一种树，不如说它是通过传统索引组织有序文件或内存块的一种方式。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/LSM_Tree.png" alt="LSM_Tree"></p><p>LSM tree 的节点可以分为两种：</p><ul><li>MemTable: 保存在内存中的部分，一般可以是红黑树、跳跃表，甚至可以是 B 树。在 HBase 中使用的是跳表，在 SQLite4 中使用的是只能追加写入的红黑树。</li><li>SSTable: 保存在磁盘上的部分，一般由多个内部 KeyValue 有序的文件组成，它的 key 和 value 都是任意的字节数组，并且了提供了按指定 key 查找和指定范围的 key 区间迭代遍历的功能。SSTable 内部包含了一系列可配置大小的Block块。关于这些Block块的index存储在 SSTable 的尾部，用于帮助快速查找特定的 Block。当一个SSTable被打开的时候，index 会被加载到内存，然后根据key 在内存 index 里面进行一个二分查找，查到该 key 对应的磁盘的 offset 之后，然后去磁盘把响应的块数据读取出来。当然如果内存足够大的话，可以直接把 SSTable 直接通过 MMap 的技术映射到内存中，从而提供更快的查找。 </li></ul><p>写操作直接作用于 MemTable, 因此写入性能接近写内存。每层 SSTable 文件到达一定条件后，进行合并操作，然后放置到更高层。合并操作在实现上一般是策略驱动、可插件化的。</p><h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/LSM tree读写流程.png" alt="LSM tree读写流程"></p><h4 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h4><ol><li>当收到一个写请求时，会先把该条数据记录在 WAL（Write-ahead logging）里面，用作故障恢复。</li><li>当写完 WAL 后，会把该条数据写入内存的 MemTable 里面（删除操作也通过写入实现，会写入一个删除标记；更新则是写入一条新记录）。</li><li>当 Memtable 超过一定的大小后，会在内存里面冻结，变成不可变的 Memtable，同时为了不阻塞写操作需要新生成一个 Memtable继续提供服务。</li><li>把内存里面不可变的 Memtable 给 flush 到到硬盘上的 SSTable 层中，此步骤也称为 Minor Compaction，这里需要注意在 L0 层的 SSTable 是没有进行合并的，所以这里的 key range 在多个 SSTable 中可能会出现重叠，在层数大于 0 层之后的 SSTable，不存在重叠 key。</li><li>当每层的磁盘上的 SSTable 的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为 Major Compaction。这个阶段会真正的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间，注意由于 SSTable 都是有序的，我们可以直接采用 merge sort 进行高效合并。</li></ol><h4 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h4><ol><li>当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回。</li><li>内存查询包括服务中的 Memtable 和不可变的 Memtable，也包括对于 SSTable 的缓存 block cache。</li><li>如果内存中没有查询到就会依次下沉查询 SSTable，直到把所有的层次的 SSTable查询一遍得到最终结果。</li></ol><h3 id="写放大、读放大和空间放大"><a href="#写放大、读放大和空间放大" class="headerlink" title="写放大、读放大和空间放大"></a>写放大、读放大和空间放大</h3><p>LSM Tree 将随机写转化为顺序写，而作为代价带来了大量的重复写入。由此会引起写放大、读放大和空间放大。</p><ul><li><p>写放大（Write Amplification） :</p><p>平均写入 1 个字节，引擎中在数据的声明周期内实际会写入 n 个字节，其写放大率是 n。如果业务方写入速度是 10MB/s，在引擎端或者操作系统层面能观察到的数据写入速度是 30MB/s，系统的写放大率就是 3。写放大过大会制约系统的实际吞吐。对于 SSD 来说，也会导致 SSD 寿命缩短。</p><p>以下是 HBase 中的写放大示意图</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/写放大.png" alt="写放大示意图"></p></li><li><p>读放大（Read Amplification ）: </p><p>一个读请求，系统所需要读 n 个页面来完成查询，其读放大率是 n。逻辑上的读操作可能会命中引擎内部的 cache 或者文件系统 cache，命中不了 cache 就会进行实际的磁盘 IO，命中 cache 的读取操作的代价虽然很低，但是也会消耗 CPU。</p><p>以下是 HBase 中的读放大示意图</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/读放大.jpg" alt="读放大"></p></li><li><p>空间放大（Space Amplification）:</p><p>平均存储 1 个字节的数据，在存储引擎内部所占用的磁盘空间 n 个字节，其空间放大是 n。比如写入 10MB 的数据，磁盘上实际占用了 100MB，这是空间放大率就是 10。空间放大和写放大在调优的时候往往是排斥的，空间放大越大，那么数据可能不需要频繁的 compaction，其写放大就会降低；如果空间放大率设置的小，那么数据就需要频繁的 compaction 来释放存储空间，导致写放大增大。</p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>LSM tree 一般从以下几个方面进行优化：</p><ol><li><p>压缩</p><p>SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。</p></li><li><p>缓存</p><p>因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将 Scan 的 Block 进行缓存，从而提高检索的效率。</p></li><li><p>Bloom filter</p><p>正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以对每一个 SSTable 添加 Bloom Filter，因为 Bloom Filter 在判断一个 SSTable 不存在某个 key 的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。</p></li><li><p>合并</p><p>通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但 Compaction 操作是非常消耗 CPU 和磁盘 IO的，尤其是在业务高峰期，如果发生了 Major Compaction，则会降低整个系统的吞吐量，这也是在使用一些 NoSQL 数据库时，比如 Hbase，常常会禁用 Major Compaction，并在凌晨业务低峰期进行合并的原因。</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM tree 英文维基</a></p><p><a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree</a></p><p><a href="https://swanspouse.github.io/2019/01/28/LSM-Tree/">LSM Tree</a></p><p><a href="https://book.douban.com/subject/34819650/">HBase原理与实践</a></p><p><a href="https://zhuanlan.zhihu.com/p/32225460">PebblesDB读后感</a></p><p><a href="https://darionyaphet.github.io/2018/10/06/RocksDB/">RocksDB</a></p><p><a href="https://zhuanlan.zhihu.com/p/65557081">LSM-tree减少写放大的一些策略</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>LSM tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法：Skip List</title>
    <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ASkip%20List/"/>
    <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9ASkip%20List/</url>
    
    <content type="html"><![CDATA[<p>Skip List（跳表）是一种能高效实现插入、删除、查找的内存数据结构。常用来对标 AVL tree 或红黑树等二叉查找树。与红黑树以及其他的二分查找树相比，跳跃表的优势在于实现简单，而且在并发场景下加锁粒度更小，从而可以实现更高的并发性。因此在一些热门项目中，如 Redis、LevelDB、HBase 都把跳跃表作为一种维护有序数据集合的基础数据结构。JDK 中也内置了基于 Skip List 实现的并发容器 ConcurrentSkipListMap 和 ConcurrentSkipListSet。</p><a id="more"></a><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>对于一个有序链表，如果要搜索一个数，需要从头到尾比较每个元素是否匹配，直到找到匹配的数为止，即时间复杂度是 $O(n)$。同理，插入或删除一个数并保持链表有序，需要先找到合适的插入或删除位置，再执行插入或删除，总计也是 $O(n)$ 的时间。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/image-20200924175020101.png" alt="image-20200924175020101"></p><p>如果链表在查找的时候，能够避免依次查找元素，那么查找复杂度将降低。而跳跃表就是利用这一思想，在链表之上额外存储了一些节点的索引信息，达到避免依次查找元素的目的，从而将查询复杂度优化为 $O(\log{}n)$。将查询复杂度优化之后，自然也优化了插入和删除的复杂度。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/image-20200924175049127.png" alt="image-20200924175049127"></p><p>我们新创建一个链表，它包含的元素为前一个链表的偶数个元素。这样在搜索一个元素时，我们先在上层链表进行搜索，当元素未找到时再到下层链表中搜索。我们以搜索数字 19 为例，先在上层中搜索，到达节点 17 时发现下一个节点为 21，已经大于 19，于是转到下一层搜索，找到的目标数字 19。</p><p>我们知道上层的节点数目为 $n/2$，因此，有了这层索引，我们搜索的时间复杂度降为了：$O(n/2)$。同理，我们可以不断地增加层数，来减少搜索的时间。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/image-20200924175111959.png" alt="image-20200924175111959"></p><p>一般地，如果有 k 层，我们需要的搜索次数会小于 $\lceil \frac{n}{2^k} \rceil + k$，这样当层数 k 增加到 $\lceil \log_{2} n \rceil$ 时，搜索的时间复杂度就变成了 $O(\log{}n)$。其实这背后的原理和二叉搜索树或二分查找很类似，通过索引来跳过大量的节点，从而提高搜索效率。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>跳跃表由多条分层的链表组成。</li><li>每条链表中的元素都是有序的。</li><li>每条链表都有两个元素：+∞（正无穷大）和-∞（负无穷大），分别表示链表的头部和尾部。</li><li>上层链表元素集合是下层链表元素集合的子集。</li><li>从上到下，上层链表元素集合是下层链表元素集合的子集。</li><li>跳跃表的高度定义为水平链表的层数。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>以左上角元素为起点。</li><li>如果当前节点的后继节点的值小于等于待查询值，则沿着这条链表向后查询，否则，切换到当前节点的下一层链表。</li><li>继续查询，直到找到待查询值或者当前节点为空。</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>先搜索得到该节点，把节点和对应的所有索引节点全部删除。</li><li>搜索过程中可以记录下路径，表面删除索引层节点时重复搜索。</li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li><p>上面的示例中简单设置了上层节点和下层节点的个数是 $1:2 $，以此决定跳表的高度。</p></li><li><p>在实际使用中，为了便于实现，采用随机算法决定每个节点的索引层数。</p></li><li><p>伪代码如下：</p><pre><code class="hljs c">randomLevel()    lvl := <span class="hljs-number">1</span>    -- random() that returns a random value in [<span class="hljs-number">0.</span>.<span class="hljs-number">.1</span>)    <span class="hljs-keyword">while</span> random() &lt; p <span class="hljs-keyword">and</span> lvl &lt; MaxLevel <span class="hljs-keyword">do</span>        lvl := lvl + <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> lvl</code></pre></li><li><p>上面的伪代码相当于抛硬币，如果是正面则层数加一，直到抛出反面为止。其中的 $MaxLevel$ 是防止如果运气太好，层数就会太高，而太高的层数往往并不会提供额外的性能，一般 $MaxLevel=log_{1/p}{n}$， $p=1/4$ 或者 $1/2$。</p></li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>在最坏的情况下，所有节点都没有创建索引，时间复杂度为 $O(n)$。但在平均情况下，搜索的时间复杂度却是 $O(\log{}n)$。一些严格的证明会涉及到比较复杂的概率统计学知识，以下只做简单说明。</p><ul><li><p>一个节点落在第 $k$ 层的概率为 $p^{k-1}$。</p></li><li><p>一个最底层链表有 $n$ 个元素的跳跃表，总共元素个数为 $\underset{k=1}{Σ} n×p^{k-1}$，其中 $k$ 为跳跃表的高度。</p><p>一个元素落在第 $k$ 层概率为 $p^{k-1}$，则第 $k$ 层插入的元素个数为 $n×p^{k-1}$，所有 $k$ 相加得到上述公式。当 $p≤ \frac{1}{2}$时，上述公式小于  $O(2n)$，所以空间复杂度为 $O(n)$。</p></li><li><p>跳跃表的高度为 $O(\log{}n)$。</p></li><li><p>跳跃表的查询时间复杂度为 $O(\log{}n)$。</p><p>为了计算搜索的时间复杂度，我们可以将查找的过程倒过来，从搜索最后的节点开始，一直向左或向上，直到最顶层。如下图，在路径上的每一点，都可能有两种情况：</p><ol><li>节点有上一层的节点，向上。这种情况出现的概率是 $p$。</li><li>节点没有上一层的节点，向左。出现的概率是 $1-p$。</li></ol><p>于是，设 <code>C(k)</code> 为反向搜索爬到第 <code>k</code> 层的平均路径长度，则有：</p><pre><code class="hljs lisp">C(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>C(<span class="hljs-name">k</span>) = p * (情况<span class="hljs-number">1</span>) + (<span class="hljs-number">1</span>-p) * (情况<span class="hljs-number">2</span>)</code></pre><p>将两种情况也用 <code>C</code> 代入，有：</p><pre><code class="hljs lisp">C(<span class="hljs-name">k</span>) = p*(<span class="hljs-number">1</span> + C(<span class="hljs-name">k</span>–<span class="hljs-number">1</span>)) + (<span class="hljs-number">1</span>–p)*(<span class="hljs-number">1</span> + C(<span class="hljs-name">k</span>))C(<span class="hljs-name">k</span>) = C(<span class="hljs-name">k</span>–<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>/pC(<span class="hljs-name">k</span>) = k/p</code></pre><p>我们知道跳表的最大层数为 $O(\log{}n)$，因此，搜索的复杂度 $O(\log{}n)/p=O(\log{}n)$。</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://lotabout.me/2018/skip-list/">跳表──没听过但很犀利的数据结构</a></p><p><a href="https://book.douban.com/subject/34819650/">HBase原理与实践</a></p><p><a href="https://xiaobaoqiu.github.io/blog/2014/12/19/javabing-fa-rong-qi-zhi-skiplist/">Java并发容器之SkipList</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
      <tag>Skip List</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase 学习：安装和使用</title>
    <link href="/2020/09/02/HBase%20%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/02/HBase%20%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍单机环境下 HBase 的安装和使用。</p><a id="more"></a><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>HBase 依赖 Hadoop，需要先安装 Hadoop 并配置。实现完全分布式配置还需要安装 ZooKeeper。</p><p>Hadoop 和 HBase 均有三种模式，Standalone、Pseudo-Distributed（伪分布式）和 Fully-Distributed。开发机资源有限，安装模式选用伪分布式。</p><h4 id="安装配置-Hadoop"><a href="#安装配置-Hadoop" class="headerlink" title="安装配置 Hadoop"></a>安装配置 Hadoop</h4><ul><li><p>下载最新稳定版并解压，本次安装使用版本为 3.2.1</p></li><li><p>配置文件</p><ul><li><p>编辑 etc/hadoop/core-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></li></ul></li><li><ul><li><p>编辑 etc/hadoop/hdfs-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></li><li><p>编辑配置 etc/hadoop/hadoop-env.sh</p><pre><code class="hljs sh"><span class="hljs-comment">#配置JAVA_HOME</span><span class="hljs-built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Hom</code></pre></li></ul></li></ul><ul><li><p>配置 ssh 免密登录本机</p><pre><code class="hljs sh">$ ssh localhost<span class="hljs-comment">#如果需要输入密码，则做以下免密配置</span>$ ssh-keygen -t rsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~/.ssh/id_rsa$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys</code></pre></li></ul><ul><li><p>启动 sbin/start-all.sh，可以通过 JPS 查看进程</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/Hadoop启动后进程.png" alt="Hadoop启动后进程"></p></li></ul><h4 id="安装配置-HBase"><a href="#安装配置-HBase" class="headerlink" title="安装配置 HBase"></a>安装配置 HBase</h4><ul><li><p>下载最新稳定版并解压，本次安装使用版本为 2.2.4</p></li><li><p>配置文件</p><ul><li><p>配置 conf/hbase-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- hdfs配置和hadoop配置对应 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000/hbase<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!-- 本地目录 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/Users/wangrui/zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>      Controls whether HBase will check for stream capabilities (hflush/hsync).      Disable this if you intend to run on LocalFileSystem, denoted by a rootdir      with the &#x27;file://&#x27; scheme, but be mindful of the NOTE below.      WARNING: Setting this to false blinds you to potential data loss and      inconsistent system state in the event of process and/or node failures. If      HBase is complaining of an inability to use hsync or hflush it&#x27;s most      likely not a false positive.    <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></li></ul></li></ul><ul><li><p>配置 conf/hbase-env.sh</p><pre><code class="hljs sh"><span class="hljs-comment">#配置JAVA_HOME</span><span class="hljs-built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home<span class="hljs-comment">#使用自带zookeeper</span><span class="hljs-built_in">export</span> HBASE_MANAGES_ZK=<span class="hljs-literal">true</span></code></pre></li></ul><ul><li><p>启动 bin/start-hbase.sh</p><ul><li><p>通过 JPS 可以查到进程</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/image-20200902103806676.png" alt="image-20200902103806676"></p></li><li><p>也可以访问 <a href="http://localhost:16010/">http://localhost:16010/</a> 查看 HBase 状态</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/image-20200902104217904.png" alt="image-20200902104217904"></p></li></ul></li></ul><h3 id="HBase-Shell"><a href="#HBase-Shell" class="headerlink" title="HBase Shell"></a>HBase Shell</h3><ul><li>进入HBase命令行：hbase shell</li><li>查看版本：version</li><li>列出所有的 namespace：list_namespace </li><li>查看有哪些表：list</li><li>建表：create ‘表名’,’列族’, ‘列族’，示例create ‘person’,’name’, ‘age’</li><li>禁用表：disable ‘表名’</li><li>删除表：drop ‘表名’</li><li>插入记录：put  ‘<table name\>‘, ‘<row\>‘, ‘<column name\>‘, ‘<value\>‘</li><li>删除记录<ul><li>删除某个属性的记录：delete ‘<table name\>‘,  ‘<row\>‘,  ‘<column name\>‘,  ‘<time stamp\>‘</li><li>删除行：deleteall ‘<table_name\>‘, ‘<row\>‘</li></ul></li><li>查询记录：get</li><li>修改记录：同插入</li><li>扫描：查看 HTable 数据。使用 scan 命令可以得到表中的数据。scan ‘<table name\>‘</li><li>统计行数：count</li><li>清空表：truncate</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">Hadoop: Setting up a Single Node Cluster.</a></p><p><a href="https://hbase.apache.org/book.html#quickstart">Quick Start - Standalone HBase</a></p>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase 学习：基础知识</title>
    <link href="/2020/08/20/HBase%20%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/08/20/HBase%20%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍 HBase 的设计目标、相关生态、数据模型和系统架构。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HBase 是高可靠性、高性能、面向列、可伸缩、可实时读写的分布式数据库，最初是 Google Bigtable 论文的开源实现。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/BigTable和HBase对照.png" alt="image-20200901155317587"></p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li><p>Scalability：HBase底层基于HDFS，支持扩展，并且可以随时添加或者减少节点</p></li><li><p>High Performance：底层的LSM-Tree数据结构，使得HBase具备非常高的写入性能。RowKey有序排列、主键索引和缓存机制使得HBase具备一定的随机读写性能。</p></li><li><p>High Availability：基于zookeeper的协调服务，能够保证服务的高可用行。HBase使用WAL和replication机制，前者保证数据写入时不会因为集群异常而导致写入数据的丢失，后者保证集群出现严重问题时，数据不会发生丢失和损坏。</p></li></ul><h3 id="相关生态"><a href="#相关生态" class="headerlink" title="相关生态"></a>相关生态</h3><p>对于 HBase 不适用的场景，可以借助于强大的生态圈，架设Phoenix、Spark或者其他第三方组件，就可以有效地扩展 HBase 的使用场景。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/HBase生态.png" alt="HBase生态"></p><ul><li>Spark：基于内存计算的大数据计算引擎，提供海量数据的离线分析计算能力和实时流计算能力</li><li>Phoenix：关系型数据库引擎，提供操作 HBase 的 SQL 接口，支持聚合运算，支持具有完整 ACID 语义的跨行及跨表事务，支持二级索引</li><li>OpenTSDB：时序数据存储，提供基于 Metrics、时间和标签的一些组合维度查询与聚合能力</li><li>GeoMesa：时空数据存储，提供基于时间和空间范围的索引能力</li><li>JanusGraph：图数据存储，提供基于属性、关系的图索引能力</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>Table（表格）</p><ul><li>A Bigtable is a sparse, distributed, persistent multi-dimensional sorted map.</li><li>一个表是一个包含海量 Key-Value 对的 Map，数据是持久化存储的。</li><li>这个大的 Map 需要支持多个分区来实现分布式。</li><li>这个 Map 按照 Key 进行排序，这个 Key 是一个由 {Row Key, Column Key, Timestamp} 组成的多维结构。</li><li>每一行列的组成并不是严格的结构，而是稀疏的，也就是说，行与行可以由不同的列组成</li></ul></li><li><p>Row（行）</p><ul><li>每一行数据都拥有一个唯一的 RowKey，可以将 Rowkey 理解为主键。</li><li>RowKey 是一个 Byte String，通常长度在 10～100Bytes 左右，建议不超过 4KB，最大为 64KB。一行中包含一个或多个列。</li><li>Bigtable支持Row级别操作的原子性。</li><li>所有的数据按照 Row Key 的字典顺序进行排序。</li><li>数据的存储目标是相近的数据存储到一起。一个常用的行的 key 的格式是网站域名。如果你的行的 key 是域名，你应该将域名进行反转 (org.apache.www, org.apache.mail, org.apache.jira) 再存储。这样的话，所有 Apache 域名将会存储在一起，好过基于子域名的首字母分散在各处。</li></ul></li><li><p>Column（列）</p><ul><li>HBase 中列的组成结构为 Family:Qualifier</li></ul></li><li><p>Column Family（列族）</p><ul><li>权限控制的最小单元。</li><li>HBase 把同一列族里面的数据存储在同一目录下，由几个文件保存。</li><li>一个 Column Family 通常是一个或多个相同类型的列的集合，这样在数据压缩率上可以获取更好的效果。</li><li>Column Families 的数量通常不建议过多，通常小于5个。</li><li>每一个列族拥有一系列的存储属性，例如值是否缓存在内存中，数据是否要压缩或者他的行key是否要加密等等</li><li>表格中的每一行拥有相同的列族，尽管一个给定的行可能没有存储任何数据在一个给定的列族中。</li></ul></li><li><p>Column Qualifier（列的限定符）</p><ul><li>列的限定符是列族中数据的索引。</li><li>例如给定了一个列族 content，那么限定符可能是 content:html，也可以是 content:pdf。</li><li>HBase 表中的每个列都归属于某个列族，列族必须作为表模式 (schema) 定义的一部分预先给出。如 create ‘test’, ‘course’。</li><li>列名以列族作为前缀，每个“列族”都可以有多个列成员 (column)。如 course:math, course:english，新的列族成员（列）可以随后按需、动态加入。</li></ul></li><li>Cell（单元）<ul><li>由行和列的坐标交叉决定。</li><li>单元格是有版本的。</li><li>单元格的内容是未解析的字节数组。</li><li>单元格是由行、列族、列限定符、值和代表值版本的时间戳组成的（{row key， column( = +)， version} ）唯一确定单元格。</li><li>cell中的数据是没有类型的，全部是字节码形式存储。</li></ul></li><li>Timestamp（时间戳）<ul><li>时间戳是写在值旁边的一个用于区分值的版本的数据。</li><li>默认情况下，时间戳表示的是当数据写入时RegionSever的时间点，但你也可以在写入数据时指定一个不同的时间戳。</li><li>在HBase每个cell存储单元对同一份数据有多个版本，根据唯一的时间戳来区分每个版本之间的差异，不同版本的数据按照时间倒序排序，最新的数据版本排在最前面。</li><li>时间戳的类型是 64 位整型。时间戳可以由 HBase（在数据写入时自动）赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。</li></ul></li><li>Region（域）<ul><li>BigTable中称为Tablet</li><li>HBase自动把表水平划分成多个区域（Region），每个Region会保存一个表里面某段连续的数据。</li><li>Region是数据分布与负载均衡的基本单元。</li><li>每个表一开始只有一个Region，一个Region增长到一定大小之后可以自动分裂成两个Region。</li><li>多个Region可以合并成一个大的Region。</li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h4><p>一个名为 webable 的表格，表格中有两行（com.cnn.www 和 com.example.www）和三个列族（contents, anchor 和 people）。在这个例子当中，第一行（com.cnn.www）中anchor包含两列（anchor:cssnsi.com， anchor:my.look.ca）和 content 包含一列（contents:html）。这个例子中 com.cnn.www 拥有5个版本而 com.example.www 有一个版本。contents:html 列中包含给定网页的整个 HTML。anchor 限定符包含能够表示行的站点以及链接中文本。people 列族表示跟站点有关的人。</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/HBase逻辑视图.png" alt="HBase逻辑视图"></p><h4 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h4><p>尽管一个概念层次的表格可能看起来是由一些列稀疏的行组成，但他们是通过列族来存储的。一个新建的限定符 （column_family:column_qualifier）可以随时地添加到已存在的列族中。</p><p>列族 anchor 的所有数据存储在一起：</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/列族存储示例1.png" alt="列族存储示例1"></p><p>列族 contents 的所有数据存储在一起：</p><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/20200901162726.png" alt="列族存储示例2"></p><p>在HBase中，表格中的单元如果是空将不占用空间或者事实上不存在。因此对于返回时间戳为 t8 的 contents:html 的值的请求，结果为空。同样的，一个返回时间戳为 t9 的anchor:my.look.ca 的值的请求，结果也为空。如果没有指定时间戳的话，会返回特定列的最新值。对有多个版本的列，优先返回最新的值，因为时间戳是按照递减顺序存储的。因此对于一个返回 com.cnn.www 里面所有的列的值并且没有指定时间戳的请求，返回的结果会是时间戳为 t6 的contents:html 的值、时间戳 t9 的 anchor:cnnsi.com 的值和时间戳 t8 的 anchor:my.look.ca。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://cdn.jsdelivr.net/gh/popesaga/img/img/HBase体系结构.png" alt="HBase体系结构"></p><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><ul><li>包含访问 HBase 的接口并维护 cache 来加快对 HBase 的访问。</li><li>HBase客户端访问数据行之前，首先需要通过元数据表定位目标数据所在RegionServer，之后才会发送请求到该RegionServer。</li><li>同时这些元数据会被缓存在客户端本地，以方便之后的请求访问。</li><li>如果集群RegionServer发生宕机或者执行了负载均衡等，从而导致数据分片发生迁移，客户端需要重新请求最新的元数据并缓存在本地。</li></ul><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><ul><li>保证任何时候，集群中只有一个工作状态的 master。</li><li>存储 HBase 的 schema 和 table 元数据。</li><li>存储所有 Region 的寻址入口。</li><li>实时监控 RegionServer 的上线和下线信息,并实时通知 Master。</li><li>通过心跳可以感知到 RegionServer 是否宕机，并在宕机后通知 Master 进行宕机处理。</li><li>HBase中对一张表进行各种管理操作（比如 alter 操作）需要先加表锁，防止其他用户对同一张表进行管理操作，造成表状态不一致。和其他 RDBMS 表不同，HBase 中的表通常都是分布式存储，ZooKeeper 可以通过特定机制实现分布式表锁。</li></ul><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><ul><li>处理用户的各种管理请求，包括建表、修改表、权限操作、切分表、合并数据分片以及 Compaction 等。</li><li>管理集群中所有 RegionServer，包括为 RegionServer 分配 region，负责 RegionServer 的负载均衡、RegionServer 的宕机恢复以及 Region 的迁移等。</li><li>清理过期日志以及文件，Master 会每隔一段时间检查 HDFS 中 HLog 是否过期、HFile 是否已经被删除，并在过期之后将其删除。</li></ul><h4 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h4><ul><li>主要用来响应用户的 IO 请求，是 HBase 中最核心的模块，由 WAL（HLog）、BlockCache 以及多个 Region 构成。</li><li>WAL 用来保证数据写入的可靠性。</li><li>BlockCache 可以将数据块缓存在内存中以提升数据读取性能。</li><li>Region 是 HBase 中数据表的一个数据分片，一个 RegionServer 上通常会负责多个 Region 的数据读写。</li><li>一个 Region 由多个 Store 组成，每个 Store 存放对应列簇的数据，比如一个表中有两个列簇，这个表的所有 Region 就都会包含两个 Store。</li><li>每个 Store 包含一个 MemStore 和多个 HFile，用户数据写入时会将对应列簇数据写入相应的 MemStore，一旦写入数据的内存大小超过设定阈值，系统就会将 MemStore 中的数据落盘形成HFile文件。</li><li>HFile 存放在 HDFS 上，是一种定制化格式的数据存储文件，方便用户进行数据读取。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://book.douban.com/subject/34819650/">HBase原理与实践</a></p>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写作工具配置：Typora + PicGo + GitHub 图床</title>
    <link href="/2020/08/02/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%EF%BC%9ATypora%20+%20PicGo%20+%20GitHub%20%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/08/02/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%EF%BC%9ATypora%20+%20PicGo%20+%20GitHub%20%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h3><h4 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h4><ul><li>支持 Markdown 的文本编辑器<ul><li>常见的文本编辑器如 VS Code 、Sublime Text 都可以原生或者通过扩展支持 MarkDown。也可以选择专门的 MarkDown 编辑器：<a href="https://www.v1tx.com/post/best-markdown-editor/#typora">7款好用的 MarkDown 编辑器推荐</a>。</li><li>选择文本编辑器写作，就必须要熟悉 MarkDown 的语法。好在 MarkDown 的语法比较简单，号称五分钟就能上手，剩下的就多写多练了。</li></ul></li><li>富文本编辑器<ul><li>语雀、简书等</li><li>还可以选择富文本编辑器，这里所说的富文本编辑器主要指所见即所得，无须使用 MarkDown 语法就可以使用的编辑器，一般是在线编辑器。好像曾经有道云笔记曾经支持过，但是现在已经没有了。现在可以选择的有简书和语雀。好处是可以省掉学习 MarkDown 语法的过程。而且一般还有一些功能上的扩展，比如贴图即上传到对应服务器的图床上。如何解决图床问题也是博客写作的一个门槛，但是使用富文本编辑器就可以直接上传到对应编辑器的服务器上。</li></ul></li></ul><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>之前在阿里工作的时候，内部就使用过语雀，用的还比较习惯。也看到有人写平时都用语雀编辑完导出再上传到博客。不过都已经开始自己折腾了博客了，这样搞感觉还不如就拿语雀做笔记了，导来导去有点多此一举。我也有心想学一下 MarkDown。</p><p>综合各种推荐，特别是 Mac 环境下，最终选择 Typora 做编辑器。Typora 最大的特点就是可以所见即所得，另外对图片插入支持较好。除此之外的其他特点可以参考介绍：<a href="https://sspai.com/post/54912">Typora 完全使用详解</a> 和 <a href="https://www.typora.net/">官网</a>。</p><h3 id="MarkDown-语法"><a href="#MarkDown-语法" class="headerlink" title="MarkDown 语法"></a>MarkDown 语法</h3><ul><li><a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown 基本语法</a></li><li><a href="[https://yuhongjun.github.io/tech/2017/05/02/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88.html#33-%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5](https://yuhongjun.github.io/tech/2017/05/02/Markdown-语法手册-完整整理版.html#33-自动链接">Markdown 语法手册 （完整整理版）</a>)</li><li><a href="https://markdown-zh.readthedocs.io/en/latest/">Markdown 中文文档</a></li></ul><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>MarkDown 写文档要想写的爽，另外一个要解决的问题就是如何插入图片。当然也可以选择直接在资源目录下配置图片，用相对路径访问。更好的解决方式是使用图床。图床的选择又是个纠结的过程，下面会结合使用的工具介绍如何选择。</p><h4 id="图床选择"><a href="#图床选择" class="headerlink" title="图床选择"></a>图床选择</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/35270383">盘点国内免费好用的图床</a></li><li><a href="https://meta.appinn.net/t/topic/13989">2020国内能用的图床集合</a></li></ul><p>简单的说如果想免费，博客又选择备案的情况下最推荐使用的是七牛云。如果想免费，又不想备案，一般会推荐使用一些久经考验的公共图床。当然公共图床也可以有会员服务。还要考虑访问问题，国内的图床服务基本上都必须备案，而很多海外用的多的图床又被墙了。备案的问题也有解法，但是我不想搞这么复杂。</p><p>比较推荐的公共图床有 sm.ms 和路过图床。公共图床的问题就是说不定哪天就没了或者被墙了。不过国内的互联网的互联网服务，又何尝不是说没就没呢？互联网没有永恒。</p><p>在纠结中发现有的图床工具内置支持的上传图床有 GitHub。GitHub 不是最被推荐的选择，主要问题和用 GitHub 搭博客一样，国内访问慢，有被墙的风险。不过既然我的博客已经是搭在 GitHub 上了，图床也用博客至少能保证图床不会比博客先挂。我的博客也不想要做成什么吸引访问的站点，主要是用作整理记录而已。因此最后选择用 GitHub 搭建图床。如果以后博客想更新换代或者去做备案了，到时候再更换图床吧。</p><p>再说一下选择的图床工具。基本上最推荐的工具就俩，iPic 和 PicGo。iPic 原来几乎是 Mac 下的最佳选择，久经考验。并且可以和 Typora 集成，在Typora 中粘贴图片可以自动上床到图床。但是除了默认图床（似乎是已经用不了的微博图床），想选择使用其他图床需要付费。PicGo 也是很多人推荐的，并且是开源且免费的。在最近的版本更新中 Typora 也集成了使用 PicGo 做图像上传服务，内置的图床又已经配好了 GitHub。那我想就无须再纠结，就使用 PicGo + GitHub 做图床好了。</p><h4 id="GitHub-配置"><a href="#GitHub-配置" class="headerlink" title="GitHub 配置"></a>GitHub 配置</h4><ol><li><p>创建Repository</p><p><img src="https://raw.githubusercontent.com/popesaga/img/master/img/20200803104029.png" alt="创建Repository"></p></li></ol><blockquote><ul><li>仓库最好是public的，因为private的仓库，图片链接会带token，这个token又存在过期的问题。</li><li>为repository初始化一个README.md文件可以根据需求选择，非必选</li></ul></blockquote><ol><li><p>获取授权 token</p><p>操作路径：Settings / Developer settings / Personal access tokens / Generate new Token。token 只会显示一次，注意保存。</p><p><img src="https://raw.githubusercontent.com/popesaga/img/master/img/image-20200803104504262.png" alt="获取授权 token"></p></li></ol><h4 id="PicGo-配置"><a href="#PicGo-配置" class="headerlink" title="PicGo 配置"></a>PicGo 配置</h4><ol><li><p>下载安装 PicGo 后运行。</p></li><li><p>配置图床</p><p><img src="https://raw.githubusercontent.com/popesaga/img/master/img/PicGo%20%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A" alt="PicGo 配置图床"></p></li></ol><ol><li><p>图床 CDN 配置</p><p>使用 jsDelivr 做图床 CDN，设定自定义域名为“<a href="https://link.zhihu.com/?target=https%3A//cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a>用户名/图床仓库名”</p></li><li><p>其他配置</p><p><img src="https://raw.githubusercontent.com/popesaga/img/master/img/20200803105540.png" alt="PicGo 设置"></p></li></ol><h4 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h4><p>偏好设置 / 图像 / 上传服务设定中选择 PicGo，点击“验证图片上传选项”后提示成功即配置成功。</p><p><img src="https://raw.githubusercontent.com/popesaga/img/master/img/20200803105841.png" alt="Typora 配置 PicGo"></p><h4 id="Typora-粘贴图片"><a href="#Typora-粘贴图片" class="headerlink" title="Typora 粘贴图片"></a>Typora 粘贴图片</h4><p>直接粘贴图片至文档中，会显示文件名和本地路径。Typora 自动调用 PicGo 上传图片至图床成功后会将本地路径替换为图床返回的链接地址。</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>PicGo</tag>
      
      <tag>GitHub</tag>
      
      <tag>MarkDown</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建：GitHub Pages + Hexo + Fluid</title>
    <link href="/2020/07/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%9AGitHub%20Pages%20+%20Hexo%20+%20Fluid/"/>
    <url>/2020/07/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%9AGitHub%20Pages%20+%20Hexo%20+%20Fluid/</url>
    
    <content type="html"><![CDATA[<p>搞技术的，没有一个自己的个人博客可能说不过去。有注意到最近一些访问的博客站点是使用Hexo来搭建的，看起来效果还不错。因此尝试用 Hexo 搭建一个静态的博客站点，再存放到 GitHub Pages 上。以下介绍的一些本地安装配置，均在 macOS 下操作。</p><a id="more"></a><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>首先需要安装 Git 和 Node.js ，git 已经安装好了。Mac 下安装 Node.js 需要使用 Homebrew ，之前安装的 Homebrew 已经年久失修，还需要更新。顺带补充下 Homebrew 的安装与使用。</p><h4 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h4><ul><li><p><a href="https://brew.sh/index_zh-cn.html">Homebrew 官方网站</a></p></li><li><p>安装<code>XCode</code>或者<code>Command Line Tools for Xcode</code>。Xcode可以从AppStore里下载安装，<code>Command Line Tools for Xcode</code>需要在终端中输入以下代码运行安装：</p><pre><code class="hljs bash">xcode-select --install</code></pre></li><li><p>安装Homebrew。将以下命令粘贴至终端</p><pre><code class="hljs bash">/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></code></pre><p>脚本会在执行前暂停，并说明将它将做什么。</p><blockquote><p>安装完成以后，需要运行<code>brew doctor</code>命令检测下是否有什么冲突的地方（如没有卸载<code>MacPorts</code>等等）</p></blockquote></li><li><p>基本使用</p><pre><code class="hljs bash"><span class="hljs-comment"># 搜索包</span>brew search mysql<span class="hljs-comment"># 安装包</span>brew install mysql<span class="hljs-comment"># 查看包信息，比如目前的版本，依赖，安装后注意事项等</span>brew info mysql<span class="hljs-comment"># 卸载包</span>brew uninstall wget<span class="hljs-comment"># 显示已安装的包</span>brew list<span class="hljs-comment"># 查看brew的帮助</span>brew –<span class="hljs-built_in">help</span><span class="hljs-comment"># 更新， 这会更新 Homebrew 自己</span>brew update<span class="hljs-comment"># 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span>brew outdatedbrew outdated mysql<span class="hljs-comment"># 升级所有可以升级的软件们</span>brew upgradebrew upgrade mysql<span class="hljs-comment"># 清理不需要的版本极其安装包缓存</span>brew cleanupbrew cleanup mysql</code></pre></li><li><p>brew update 时遇到的一些问题</p><p>因为网络原因，brew update 会遇到执行出错的情况。</p><ul><li><p>下载失败</p><p>解决方案，使用国内镜像。有阿里巴巴、中科大、清华等可选。但是在公司折腾了前两个都不行，换了环境之后才下载成功。归根结底可能是公司网络环境的原因，因此替换镜像的方法仅做参考。</p><p>Zsh 终端配置：</p><pre><code class="hljs bash"><span class="hljs-comment"># 替换brew.git:</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git<span class="hljs-comment"># 替换homebrew-core.git:</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span>git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git<span class="hljs-comment"># 替换homebrew-bottles:</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc<span class="hljs-built_in">source</span> ~/.zshrc<span class="hljs-comment"># 应用生效</span>brew update<span class="hljs-comment">#恢复默认配置</span><span class="hljs-comment"># 重置brew.git:</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span>git remote set-url origin https://github.com/Homebrew/brew.git<span class="hljs-comment"># 重置homebrew-core.git:</span><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span>git remote set-url origin https://github.com/Homebrew/homebrew-core.git<span class="hljs-comment">#删掉 HOMEBREW_BOTTLE_DOMAIN 环境变量，打开~/.zshrc，找到 HOMEBREW_BOTTLE_DOMAIN 这行并删除</span><span class="hljs-built_in">source</span> ~/.zshrc</code></pre></li><li><p>“Checksum mismatch”</p><p>解决方案，删除 `Archive:` 后面路径下的文件，然后再重新 update 。</p><pre><code class="hljs bash">rm -rf /Users/aici/Library/Caches/Homebrew/portable-ruby--2.6.3.mavericks.bottle.tar.gz</code></pre></li></ul></li></ul><h4 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a>Node.js 安装</h4><ul><li><p>安装 Node.js</p><pre><code class="hljs bash">brew install node</code></pre></li><li><p>版本验证</p><pre><code class="hljs bash"><span class="hljs-comment">#出现版本号即说明安装成功</span>node -vnpm -v</code></pre></li><li><p>更换 npm 源</p><pre><code class="hljs bash">npm install -g cnpm --registry=<span class="hljs-string">&quot;https://registry.npm.taobao.org&quot;</span><span class="hljs-comment">#出现结果即可证明更换成功</span>cnpm</code></pre></li></ul><h3 id="Hexo-基础"><a href="#Hexo-基础" class="headerlink" title="Hexo 基础"></a>Hexo 基础</h3><ul><li><p>安装</p><pre><code class="hljs bash"><span class="hljs-comment">#全局安装，局部安装目前看没必要</span>npm install -g hexo-cli</code></pre></li><li><p>创建文件夹</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>mkdir hexo</code></pre></li><li><p>初始化</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hexohexo init</code></pre></li><li><p>启动服务，打开 <a href="https://www.feihua.xyz/http://localhost:4000">localhost:4000</a> 即可看到 hexo 博客</p><pre><code class="hljs bash">hexo s</code></pre></li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h4><ul><li><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></p><p>看起来功能完全覆盖了 Fluid，风格也是和 Fluid 类似的。配置文档太多了加上第一眼看到的是 Fluid，就放弃这个了。 </p></li><li><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><p>先看到这个在看到的 ButterFly，功能看起来不如 ButterFly 丰富，不过第一眼印象还是更喜欢这个。</p></li><li><p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a></p><p>一个简洁也很漂亮的主题，也是让人纠结的选择。</p></li><li><p><a href="https://github.com/tufu9441/maupassant-hexo">Maupassant</a></p><p>非常简洁的主题，不想用 NexT 的可以考虑试一试。</p></li><li><p><a href="https://github.com/next-theme/hexo-theme-next">NexT</a></p><p>几乎是见的最多的主题，我心中 Hexo 博客默认的样子。功能很多，样式也很全面，几乎是不会出错的选择。</p></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>完成的配置指南参见：<a href="https://hexo.fluid-dev.com/docs/guide/">Fluid配置指南</a>。下面仅列出一些关键配置。</p><h5 id="获取最新版本"><a href="#获取最新版本" class="headerlink" title="获取最新版本"></a>获取最新版本</h5><p>请优先下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>，master 分支无法保证稳定。</p><p>下载后解压到 themes 目录下并重命名为 <code>fluid</code>。</p><h5 id="必要的配置"><a href="#必要的配置" class="headerlink" title="必要的配置"></a>必要的配置</h5><p>必须如下修改博客目录下的 <code>_config.yml</code>：</p><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，可不改</span></code></pre><h5 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h5><p>首次使用主题的「关于页」需要手动创建：</p><pre><code class="hljs bash">$ hexo new page about</code></pre><p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020-07-20 10:55:54</span><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><span class="hljs-meta">---</span><span class="hljs-comment"># 这里可以写正文</span><span class="hljs-string">支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span></code></pre><h5 id="覆盖配置"><a href="#覆盖配置" class="headerlink" title="覆盖配置"></a>覆盖配置</h5><p><strong>该功能可实现平滑升级主题，推荐所有人学习使用</strong>。</p><p>覆盖配置可以使<strong>主题配置</strong>放置在 fluid 目录之外，避免在更新主题时丢失自定义的配置。</p><p>使用该功能必须保证 Hexo 版本不低于 3.0，因为该功能利用了 <a href="https://hexo.io/zh-cn/docs/data-files.html">Hexo 数据文件</a> 功能。</p><p>使用方式：</p><ol><li>进入博客目录的 source 目录下（不是主题目录的 source），创建 <code>_data</code> 目录（和 <code>_post</code> 目录同级）；</li><li>在 <code>_data</code> 目录下创建 <code>fluid_config.yml</code> 文件，将 <code>/theme/fluid/_config.yml</code> 中全部配置（或部分配置）复制到 <code>fluid_config.yml</code> 中；</li><li>以后配置都在 <code>fluid_config.yml</code> 中修改，配置会在 <code>hexo g</code> 时自动覆盖。</li></ol><p>TIP</p><ul><li>也可以只覆盖部分配置，但注意只要存在于 <code>fluid_config.yml</code> 的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的。</li><li>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 <code>fluid_config.yml</code> 同步修改。</li><li>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code> 查看命令行输出。</li></ul><p>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</p><pre><code class="hljs yaml"><span class="hljs-attr">about:</span>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icon 注释掉，否则无法覆盖配置</span>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span></code></pre><h5 id="博客标题"><a href="#博客标题" class="headerlink" title="博客标题"></a>博客标题</h5><p>页面左上角的博客标题，默认使用<strong>博客配置</strong>中的 <code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。</p><p>如需单独区别设置，可在<strong>主题配置</strong>中设置：</p><pre><code class="hljs yaml"><span class="hljs-attr">navbar:</span>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">博客标题</span></code></pre><h5 id="统计-PV-与-UV"><a href="#统计-PV-与-UV" class="headerlink" title="统计 PV 与 UV"></a>统计 PV 与 UV</h5><p>页脚可以展示 PV 与 UV 统计数据，目前支持两种数据来源：<a href="https://www.leancloud.cn/">LeanCloud</a> 与 <a href="http://busuanzi.ibruce.info/">不蒜子</a>。此处使用 LeanClound，需要注册后填写相关配置才生效。</p><ul><li>注册 LeanClound 账号</li><li>创建应用</li><li>将应用的 AppId、 AppKey 和 REST API 服务器地址粘贴到 web_analytics 下对应位置</li><li>创建 Class 存储访问量等数据</li><li>footer.statistics.source 填写 leancloud</li></ul><h5 id="首页-Slogan（打字机）"><a href="#首页-Slogan（打字机）" class="headerlink" title="首页 Slogan（打字机）"></a>首页 Slogan（打字机）</h5><p>首页大图中的打字机文字，可在<strong>主题配置</strong>中设定是否开启：</p><pre><code class="hljs yaml"><span class="hljs-attr">index:</span>  <span class="hljs-attr">slogan:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">text:</span> <span class="hljs-string">这是一条</span> <span class="hljs-string">Slogan</span></code></pre><p>如果 <code>text</code> 为空则按<strong>博客配置</strong>的 <code>subtitle</code> 显示。</p><p>相关的打字机动效设置在：</p><pre><code class="hljs yaml"><span class="hljs-attr">fun_features:</span>  <span class="hljs-attr">typing:</span> <span class="hljs-comment"># 为 subtitle 添加打字机效果</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span> <span class="hljs-comment"># 打印速度</span>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span> <span class="hljs-comment"># 游标字符</span>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否循环播放效果</span></code></pre><p>并不是很喜欢打字效果，直接关闭了。</p><h5 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h5><p>开关自动摘要（默认开启）：</p><pre><code class="hljs yaml"><span class="hljs-attr">index:</span>  <span class="hljs-attr">auto_excerpt:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre><p>若要手动指定摘要，使用 <code>&lt;!-- more --&gt;</code> MD文档里划分，如：</p><pre><code class="hljs markdown">这里是摘要<span class="xml"><span class="hljs-comment">&lt;!-- more --&gt;</span></span>这里是正文</code></pre><p>按照配置文档里使用 <code>&lt;!-- more --&gt;</code> 后会报错，并且摘要未生效。如果配置 Front-matter 可以解决。未配置 Front-matter 时，也可以通过添加 —- 水平线解决，没有查到相关文档的解释。</p><p>或者在 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a> 里设置 <code>excerpt</code> 字段，如：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">这是标题</span><span class="hljs-attr">excerpt:</span> <span class="hljs-string">这是摘要</span><span class="hljs-meta">---</span></code></pre><blockquote><p>TIP</p><p>优先级: 手动摘要 &gt; 自动摘要</p><p>如果关闭自动摘要，并且没有设置手动摘要，摘要区域空白</p><p>无论哪种摘要都最多显示 3 行，当屏幕宽度不足时会隐藏部分摘要。</p></blockquote><h5 id="文章内容图片"><a href="#文章内容图片" class="headerlink" title="文章内容图片"></a>文章内容图片</h5><p>本地图片存放位置同上。</p><pre><code class="hljs markdown">![](/img/example.jpg)</code></pre><h5 id="日期-字数-阅读时长-阅读数"><a href="#日期-字数-阅读时长-阅读数" class="headerlink" title="日期/字数/阅读时长/阅读数"></a>日期/字数/阅读时长/阅读数</h5><p>显示在文章页大标题下的文章信息，除了阅读次数，其他功能都是默认开启的。</p><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <span class="hljs-attr">meta:</span>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 日期</span>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span>    <span class="hljs-attr">views:</span>  <span class="hljs-comment"># 阅读次数</span>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span></code></pre><h5 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h5><p>开启评论需要在<strong>主题配置</strong>中开启并指定评论模块：</p><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <span class="hljs-attr">comments:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span></code></pre><p>比较推荐的主要是两个：utterances 和 valine。此处使用valine，据说配置方便又简约，基于 Leancloud 的无后端设计。</p><ul><li>请先<a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>或<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> <code>LeanCloud</code>, 进入<a href="https://leancloud.cn/dashboard/applist.html#/apps">控制台</a>后点击左下角<a href="https://leancloud.cn/dashboard/applist.html#/newapp">创建应用</a></li><li>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了</li><li>创建 Class 存储评论数据</li><li>将应用的 AppId、 AppKey 和 REST API 服务器地址粘贴到 valine 下对应位置</li><li>其他配置视情况需要修改</li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><p>主题内置了脚注语法支持，可以在文章末尾自动生成带有锚点的脚注，该功能在<strong>主题配置</strong>中默认开启：</p><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <span class="hljs-attr">footnote:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;&#x27;</span></code></pre><p>脚注语法如下：</p><pre><code class="hljs markdown">这是一句话[^1][<span class="hljs-symbol">^1</span>]: <span class="hljs-link">这是对应的脚注</span></code></pre><p>更优雅的使用方式，是将脚注写在文末，比如：</p><pre><code class="hljs markdown">正文<span class="hljs-section">## 参考</span>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">参考资料1</span>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">参考资料2</span></code></pre><p>当然你也可以通过修改上方配置项 <code>header</code> 来自动加入节标题，如下所示：</p><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <span class="hljs-attr">footnote:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;&lt;h2&gt;参考&lt;/h2&gt;&#x27;</span>  <span class="hljs-comment"># 等同于手动写 `## 参考`</span></code></pre><h5 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h5><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><pre><code class="hljs subunit">categories:- Diary<span class="hljs-keyword">tags:</span>- PS3- Games</code></pre><blockquote><p>分类方法的分歧</p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><pre><code class="hljs markdown">categories:<span class="hljs-bullet">  -</span> Diary<span class="hljs-bullet">  -</span> Life</code></pre><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><pre><code class="hljs asciidoc">categories:<span class="hljs-bullet">- </span>[Diary, PlayStation]<span class="hljs-bullet">- </span>[Diary, Games]<span class="hljs-bullet">- </span>[Life]</code></pre><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><h5 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h5><p>在github上创建博客的仓库，创建仓库地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/new">https://github.com/new</a>。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io。</p><h5 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h5><ul><li><p>修改博客目录下的 <code>_config.yml</code></p><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>    <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;你的</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">用户名&gt;/&lt;你的</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">用户名&gt;.github.io</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre><blockquote><p>TIP</p><p>官方教程有坑！</p><p>- <code>github.com/username/username.github.io</code> 这样的仓库用<code>master</code>分支 </p><p>- <code>github.com/username/cengjingbeikengguo</code> 这样的用<code>gh-pages</code></p></blockquote></li><li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>，使用 cnpm</p><pre><code class="hljs sql">$ cnpm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre></li><li><p>生成站点文件并推送至远程库。 hexo clean &amp;&amp; hexo deploy</p><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo deploy</code></pre></li><li><p>登入 Github，请在库设置（Repository Settings）中将默认分支设置为 _config.yml 配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</p></li></ul><h3 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h3><h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><pre><code class="hljs bash"><span class="hljs-comment"># 创建新文章</span>hexo new <span class="hljs-string">&quot;xxx xxx xxx&quot;</span><span class="hljs-comment"># 测试</span>hexo s<span class="hljs-comment"># 生成站点并部署</span>hexo d -g</code></pre><h3 id="更新-hexo-及插件"><a href="#更新-hexo-及插件" class="headerlink" title="更新 hexo 及插件"></a>更新 <code>hexo</code> 及插件</h3><p>更新 <code>hexo</code></p><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> update -g hexo</code></pre><p>更新插件</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> update</code></pre><h3 id="更换电脑"><a href="#更换电脑" class="headerlink" title="更换电脑"></a>更换电脑</h3><ul><li>使用 git 同步</li><li>使用坚果云选择性同步这几个文件夹。然后在另一台电脑上搭建博客环境、安装相关插件后。同步这些文件，然后重新生成、部署站点。</li></ul><h3 id="提交到-Google-收录"><a href="#提交到-Google-收录" class="headerlink" title="提交到 Google 收录"></a>提交到 Google 收录</h3><h4 id="网址验证"><a href="#网址验证" class="headerlink" title="网址验证"></a>网址验证</h4><ol><li><p>进入<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a> 登录你的谷歌账号</p></li><li><p>在网址前缀中填写地址</p></li><li><p>下载验证文件</p></li><li><p>拷贝到你的本地博客hexo/sources/ 下</p><p>&gt;<br>&gt;</p><blockquote><p><strong>注意</strong>：hexo在部署source 文件夹下markdown语法格式的文件成html格式时（本身文件格式就是html格式），都会遵守固有的html布局格式，<strong>所以后面Google验证html文件时，此时的“html验证文件”已经不是原本下载的文件，变成遵守固有布局的html文件</strong>，为了正常验证步骤进行，部署服务器前必须先打开“html验证文件“，加入以下内容，让固有的html布局失效。</p><pre><code class="hljs xml">&gt;layout: false&gt;---</code></pre></blockquote></li><li><p>部属到GitHub远程仓库</p><pre><code class="hljs bash">hexo g -d</code></pre></li><li><p>本地操作完成后，继续返回到网站页面，点击验证，成功！</p></li></ol><h4 id="生成站点地图"><a href="#生成站点地图" class="headerlink" title="生成站点地图"></a>生成站点地图</h4><p>在本地Hexo博客根目录下安装 sitemap 生成插件</p><pre><code class="hljs bash">npm install hexo-generator-sitemap --save</code></pre><p>编辑站点目录下的_config.yml配置文件，添加以下字段：</p><pre><code class="hljs yaml"><span class="hljs-comment"># 自动生成sitemap</span><span class="hljs-attr">sitemap:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><span class="hljs-comment"># 修改url为网站地址</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://popesaga.github.io/</span></code></pre><p>部署到远程仓库</p><pre><code class="hljs sh">$ hexo g -d</code></pre><h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><p>这时在远程仓库根目录就可以看到<code>sitemap.xml</code>文件了。<br>返回<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">谷歌站点地图</a>，选择已经验证过的站点，在站点地图 中，添加新的站点地图，添加 sitemap.xml 的链接。</p><p>添加成功后等待 google 收录即可。</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Homebrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
